---
date: 2017-04-13
layout: post
title: Æternity(安特元)区块链白皮书
categories: 技术
tags: blockchain aeternity
---
## Æternity(安特元)区块链白皮书
*分布式去中心化的函数式预言机*

时间：2017-02-06

版本：0.1

作者：Zackary Hess(ack@aeternity.com)、Yanislav Malahov(yani@aeternity.com)、Jack Pettersson(jack@aeternity.com)

编译：Qian Xiaowei(barakawei@me.com)

摘要 - 自从2014年推出Ethereum(以太坊)以来，对分布式去中性化应用(智能合约)感兴趣的人越来越多，许多人尝试在区块链上构建连接真实世界数据的应用，在这过程中，我们认为在on-chain(链上)保存应用状态和代码是一种不合理的实现方式。

因此，我们提出了一种高度可扩展的区块链架构，其共识机制可以用来检查oracle(预言)的正确性，这将使得预言变得非常有效率，因为它避免了分层的共识机制。另外，State Channels(状态通道)概念将被集成进区块链架构中，用以提高区块链的隐私性和可扩展性，同时在状态通道中可以编写纯
粹的函数式智能合约来实现Tokens(代币)的转移和对预言答案的访问。在此架构中，由于合约代码或应用状态不在链中保存，而是在状态通道中保存，我们可以使得智能合约在不损失实质功能的前提下，变得简单和而有效率。
	
通过这种架构，我们可以大规模，有效的实现类似代币资产和预测市场等应用。架构中某些部分的概念验证已通过Erlang语言实现，钱包、域名系统和认证系统等基本应用组件也将不久后提供。

1.介绍
    
本论文的目的是概述Æternity(安特元)区块链的架构和一些可能的应用场景，将来会有更详细的论文来专门阐述共识和治理机制。
需要指明的是，我们的架构设计是整体性的，所有的组件会以模块化的方式整合在一起协同工作。
	
本论文分为四个部分。首先，我们将介绍和讨论安特元架构的基本理论思想。二，我们会讨论一下基础应用和一些可能的应用场景，这会给开发者提供一些思路，让他们了解如何使用本平台来开发应用。三，我们将展现用Erlang语言来实现验证安特元区块链的核心概念。最后，我们作一下讨论，总结下未来可能的发展方向和与其他技术的比较。

A.前期工作
	
比特币作为区块链技术的先驱，给大家展现了一种在互联网上建立价值交换[1]的方式。在这之后又出现了多种新的技术进展：
以太坊展示了一种通过区块链来实现图灵完备智能合约的方式[2]；
Truthcoin在区块链上创建了可以实现预测的工具[3]；
而GroupGnosis和Augur则展示了如何使预测变得更加高效[4]；
Casey Detrio展示了如何在区块链上做市场[5];
Namecoin(域名币)展示了如何实现分布式等价的域名服务器[6];Factom展示了如何在区块链上通过存储哈希来给数字资产作存在性证明[7]。
	
随着区块链技术的发展，其在金融和法律服务领域展现出了广阔的应用前景。但到目前为止，还没有一个完整统一的系统来实现人们所期望的景象。
特别地，在当前已知的所有解决方案中，在管理性、扩展性、脚本安全性和廉价获取真实世界数据[need cit.]方面，都至少存在一个或多个方面的缺失。
安特元的目标就是要整合和发展这些技术，创造出一个完整统一的区块链平台。

II. ÆTERNITY BLOCKCHAIN(安特元区块链)

我们认为当前“智能合约平台”缺乏可扩展性、脚本安全性和廉价连接现实世界数据的原因可以归结为三个核心问题。首先，当前盛行的有状态设
计使得智能合约难以被分析，并且结合有序的交易状态使得可扩展性变得复杂[need cit.]。二，通过分布式去中心化的方式，将现实世界数据带入区块链
系统的成本过于高昂，使得不少有创意的应用变得复杂而不可实现[need cit.]。三，这些平台的自我更新能力有限，无法适应新的技术和经济知识。我们
认为，这三个问题中的每一个都是有明确解决途径的，应该深入探索。

首先，最近对state channel(状态通道)技术的研究表明，对于许多用例来说，保持状态在链上是不必要的[need cit.]。通常的做法是将所有状态
信息保存在状态通道中，仅使用区块链来处理信息交换后产生的经济结果，以及处理在出现争议情况下的回退。这为区块链架构提供了一种新的思路，图灵
完备的智能合约可以通过状态通道来实现，而不需要在链上实现。这增加了可扩展性，因为所有的交易都可以被独立的和并行的处理。此外，这意味着合约
永远不会写入共享状态，大大简化了他们的测试和验证。 我们认为这个设计强调了区块链是与金融逻辑相关而不是数据存储; 而现有的分布式存储解决方
案，可以完美的补充区块链在数据存储方面的不足。

第二，像Augur这样的应用尝试以分布式去中心化的方式，把真实世界的数据带入到区块链中-这本质上是在智能合约中建立了新的共识机制[8]，
而不是利用底层区块链的共识机制来实现。 这导致其实现方式效率低下，并增加了风险。 显而易见，一种自然的实现方式是
通用化底层的共识机制，使其不仅能够提供内部的状态，而且可以提供外部世界的状态。 鉴于此，有种观点认为这种共识机制可以实现对一些理论上比较
复杂的结果判定，这就是oracle machine(预言机)：一个比图灵机更强大的理论机器，因为它可以回答一些无法通过计算解决的问题，比如“某场足球比赛
谁能赢？“[need cit.]。
	
第三，自然地这种共识机制在运行时可以改变系统的参数，这使得它可以适应不断变化的外部条件，也可以适应新的研究和发展状况。
本节的其余部分将先从帐户，代币，命名和块链结构等方面更详细的介绍安特元区块链技术架构，其次描述状态通道和智能合约的实现方式，然后
讨论区块链共识机制是如何用来创造一个高效的oracle mechanism(预言机制)和治理机制。 最后，我们从几个不同的角度讨论其扩展性。

A.Tokens, accounts and blocks(代币、账户和块链)

虽然智能合约的“无状态”，已经是合约开发者的一种共识，但是安特元区块链仍然会对一些预定义的组件保持状态。马上我们将按照每个模块来阐述这些
内容。 为了简单起见，本节假设每个节点都记录着整个块链，一些可能的优化在II-E章节中进行描述。

A.1) Access token, Aeon(使用代币，安币)：使用区块链不是免费的，需要用户花费一个名为aeon(安币)的代币。安币可以用于支付平台上任何消耗资
源的应用，比如在平台上实现的基础金融应用。存在与创世块中的安币，将通过以太坊的智能合约来分发，未来安币将通过挖矿的方式发行。
平台中所有的手续费都通过安币来支付，所有智能合约的流通媒介也是安币。

A.2) Accounts(账户)：每个账户都包含地址、安币余额和一个随机数，随机数的生成规则随着每笔交易和块高度而变化。同时每个账户根据开户时间必须要支付一笔小额手续费，创建和保存账户的成本用于防止垃圾数据的无限制膨胀，而删除账户回收空间则可以获得一定的奖励。

A.3) Name system(域名系统)：许多区块链系统的账户地址都是一串哈希值，对用户来说无可读性。借鉴Aaron Swartz的工作和域名币设计，安特元的特性之一是拥有一个分布式又安全的域名系统，使得账户可以支持人性化的名字[9]。区块链状态中包含一个唯一性字符串到固定大小字节数组的映射，这些字符串可以用来指向帐户地址或者默克尔树的哈希。

A.4）Block Contents(块内容)：每个块包含以下组件：
* 上一个块的哈希。
* 交易的默克尔树。
* 帐户的默克尔树。
* 域名的默克尔树。
* 已开通道的默克尔树。
* 还没有回答问题的预言机的默克尔树。
* 预言机答案的默克尔树。
* 默克尔证明的默克尔树。
* 随机数发生器当前的熵。

前一个块的哈希用来维护区块链的有序性，交易树包含了当前块中的所有的交易。 除了共识投票树以外，其他所有的树都在共识机制下：如果一棵树从一个块到下一个块
之间发生了变化，那这个变化必须通过交易打包到一个新的块链交易树中，并且一个默克尔更新证明必须包含在块的证明树中。 剩下三棵树的作用，希望在接下来的章节中能够描述清楚。

B.State channels(状态通道)

在最近的区块链发展中，一个最有趣的发现是状态通道，它们在大多数情况下按照基本原则执行，只有人受交易影响时才需要去了解它。 本质上，交易方在块链上实例化一些状态，例如：一个以太坊智能合约或一个比特币多方签名。然后他们在彼此间简单的发送经过签名更新后的状态，关键点在于他们中的任何一个都可以使用这些来更新块链中的状态，虽然在大多数情况下不需要这么做。 这将使得交易各方处理交易的速度可以与信息传输一样快，而不需要等到交易已验证-最终确定-通过区块链共识机制这些流程的执行完成。

在安特元中，唯一需要更新的状态是安币的转移，并且只有交易方已经存入通道中的安币才可以被转移。 这使得所有通道彼此独立，其直接好处是任何通道中的交易都可以并行处理，极大的提高了交易吞吐量。

区块链只用于处理最终交易输出或解决所产生的冲突，这大致类似于司法系统。 不过，因为区块链的行为将是可预测的，对状态通道预期输出结果产生争议是没有益处的；恶意者也没有动力去做不正确的行为，只能在区块链的最终状态上作处理。所有这些综合起来，这将提升几个数量级的交易速度和交易量，而且保证了隐私性。

B.1) Smart Contracts(智能合约)：虽然链上唯一可以保存的状态是安币的转移，但是安特元仍然有一个图灵完备的虚拟机可以运行“智能合约”。 
安特元上的合约是一种严格的协议，按照一些规则分配资金，与以太坊上的合约相比有一些明显的不同。两个显著的差异是，默认情况下只有双方才知道给定的合约，而且只有双方拥有开放的状态通道时才可以创建有效的合约。如果双方同意合约，他们签名并保留副本以备将来参考，只有当双方对结果产生争议时，才提交到区块链上，在这种情况下，合约代码只作为的交易的一部分保存，而不保存其他任何状态，如果争议的情况发生，区块链会根据合约来重新分配安币，并且关闭状态通道。

```
1 macro Gold f870e8f615b386aad5b953fe089;
2
3 Gold oracle
4 if 0 1000 else 0 0 end
5 0
```
*示例1：一个简单的合约编码，可以用来对赌黄金价格，编写语言使用的是Chalang类似Forth-like语法，将在第IV-A节中介绍。*

例如，示例1显示了一个非常简单的合约，在一定时间内根据黄金的价格来打赌。 第1行，macro是宏关键字，Gold是宏的名称，后面的哈希值是预言机中问题的唯一标识，问题的内容为在2016年12月1日时如果黄金价格低于38美元/克，则这个宏的返回结果为true。合约的正文在第2-4行显示：我们首先把问题的唯一标识压入栈中，并使用预言机调用它，预言机会把答案放到栈顶部， 我们用这个答案作条件判断：如果预言机返回true，我们把0和1000放到栈中，0表示没有安币需要被消耗，1000表示通道中有1000个安币需要被转移给第一个参与方，反过来如果返回false，我们把0和0放到栈中，第二个0表示另一个参与方获得通道中所有的安币，最后的0表示通道状态的随机值，在实际使用场景中，随机数将在部署时生成。

一个需要注意的重要事情是安特元上的智能合约不维护自己的任何状态，合约状态是由交易方维护，并在合约执行时作为输入。每个合约本质上是个纯函数，根据一些输入参数，输出新的通道状态。 一般在软件开发中，使用纯函数是有益处的，特别是在金融应用的开发过程中，这已在学术界和工业界广泛论证了数十年[10]  [need cit.]

```
1 : hashlock
2 swap
3 hash
4 == ;
```
*示例2：一个简单的哈希锁*

a) Contract interaction and multi-step contracts(合约交互和多步骤合约)：即使所有的合约是无状态的并且互相独立的执行，但仍然可以通过hashlocking(哈希锁)[need cit.]来实现合约之间的交互和状态关系。 一个简单的哈希锁如示例2，第1行，我们定义一个函数称为hashlock，给定一个哈希值h和秘密值s。 在第2行对秘密值s重新赋值，然后在第3行中对秘密值s通过hash(v)函数进行哈希运算，最后在第4行比较运算后的哈希值和原来哈希值h，如果相等，则重新赋值后的秘密值s与原来的值是一致的。通过对该函数秘密值s的控制，可以实现对不同智能合约的执行逻辑进行控制。

```
1 macro Commitment a9d7e8023f80ac8928334 ;
2
3 Commitment hashlock call
4 if 0 100 else 0 50 end
5 1
```
*示例3：哈希锁可以通过中间人来实现安币的转移*

这个简单的例子显示，哈希锁使得不同用户在状态通道间存在一条路径，即使不共享状态通道，也可以实现安币的转移。例如，如果Alice和Bob有一条状态通道，
Bob和Carol也有一条通道，然后Alice和Carol的交易可以通过Bob来实现， 他们之间通过创建两个合约副本，每个通道一个合约副本来完成交易，见示例3，第1行的宏Commitment表示Alice所选择的秘密值的哈希，在第3行我们把它放到栈中并调用哈希锁函数，第四行条件分支的执行取决于哈希锁函数的返回值，一旦这些合约已经由各方签名，则Alice揭示秘密值，这允许Bob和Carol使用它来执行合约的条件逻辑，从而完成安币的转移。

```
1 macro Commitment a9d7e8023f80ac8928334 ;
2
3 Commitment hashlock call
4 if State33 else State32 end
5 call
```
*示例4：一个简单的例子，使用哈希锁在通道中玩一个多方参与的游戏*

哈希锁也可以用于在状态通道中实现多方参与的游戏，见示例4，每个人都和游戏管理者建立了一条状态通道，每个通道中都包含了一个相同的智能合约，通过函数State32来声明，当前我们处于游戏状态32，以及我们想要同时把所有通道中的游戏状态更新到33。当游戏管理者揭示秘密值时，所有通道中的合约将同时执行更新。
